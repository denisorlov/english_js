<!DOCTYPE html>
<html>
<head>
    <meta property="og:title" content="Универсальный Тренажер"/>
    <meta property="og:description" content="Веб-приложение 'Универсальный Тренажер' для изучения/повторения чего угодно, адаптировано под мобильные устройства."/>
    <!--meta property="og:image" content="http://denisorlovmusic.ru/english4040/i/exam.png"/>
    <meta property="og:url" content= "http://denisorlovmusic.ru/english4040/exam.html"/-->

    <!--script type="text/javascript" src="http://yandex.st/jquery/1.6.1/jquery.min.js"></script-->
    <title>Универсальный Тренажер</title>
	<style>
textarea{
	display:none;
	width: 96%
}
#lessonCombo{
	width: 100%;
	font-size: 20px;
}
#swMesure{
    border-radius: 3px;
}
.contentPanel{
    float: left;
    width: 83%;
	margin: 0;
}
/**/
.butPanel{
    float: right;
    width: 15%;
	margin: 0;
}	
.but{
	width: 95%;
	padding: 15% 5%;
	text-align: start;
    margin: 0 0 8% 0;
    font-size: 20px;
	display: block;
	overflow: hidden;
}
#lessonOutput{
	font-size: 24px;
	float: left;
    width: 82%;
}

.lessonPart{

}
.lessonRow{
    white-space: pre-wrap;
}

.blue{
	color: blue;
}
.green{
	color: green;
}

#infoWrap{
    display:none;
    border: 1px solid navy;
    width: 95%;
    height: 95%;
    z-index: 1000;
    background-color: rgba(255, 255, 255, 0.941176);
	color: black;
    padding: 2%;
    border-radius: 5px;
    box-sizing: border-box;
    position: fixed;
    right: 2%;;
    bottom: 2%;;
    left: 2%;
    font-size: 2em;
}
#infoPanel{
    float: right;
    width: 3.5em;
    overflow: auto;
    height: 100%;
}
.ipBut,.dcBut{
    font-weight: bold;
    font-size: 1.5em;
    margin-bottom: 2px;
}
.ipBut{
    float:right;
    font-size: 2em;
    width: 1.5em;
    height: 20%;
}
.infoContent{
    height: 100%;
    overflow: auto;
    display: none;
}
#infoSetting input,#infoSetting select{
    text-align: center;
    font-size: 100%;
    width: 20%;
    margin: 0.2em 0.2em 0 0;
}
	</style>
</head>
<body>

<div id="allLessons" style="width: 50%; float: left;">
<div id="buttonPanel">
	<button style="color: green;" title="Open editing" onclick="trainingUtils.openEditing()">✏ Open</button>
	<button style="color: red;" title="Close editing" onclick="trainingUtils.closeEditing()">🚫 Close</button>
</div>
<div class="contentPanel">
	<select id="lessonCombo"></select>
	<div id="swMesure" style="border: 1px solid green;box-sizing: border-box;position: relative;" title="">
		<!--div id="swmPosition" style="height: 90%; border: 1px solid red; position: absolute; background-color: red; left: 89%;"></div-->
		<div id="swmIndicator" style="background-color: green; text-align: center; color: white; width: 0%;"></div>
	</div>
</div>
<textarea id="lesson_11" rows=60 style="display: none">
Потоки
Создание потока:
Наследовать класс 🚩Thread
	и реализовать 🚩run()🚩:
	class MyThread extends Thread {
		public void run() {
			/* …  */
		}
	}
	запуск потока - метод 🚩start()🚩:
	MyThread myThread = new MyThread();
	myThread.start(); // а не run!

Реализовать 🚩Runnable🚩
	и передать его(либо анонимным классом) в конструктор Thread:
	Thread myThread = new Thread(new Runnable() {
		@Override
		public void run() {
			/* …  */
		}
	});

Метод myThread.🚩join()🚩 останавливает выполнение главного потока(main) до 🚩окончания🚩 присоединенного myThread.
⏸
Прерывание потока, 🚩InterruptedException🚩.
🚩interrupt()🚩 - дает потоку сигнал о 🚩прерывании🚩, но не 🚩останавливает🚩 его, а позволяет 🚩перехватить🚩 и обработать 🚩Interrupted🚩Exception либо проверить Thread.currentThread().🚩isInterrupted()🚩
⏸
Пул потоков ExecutorService
 - в конструкторе указывается 🚩количество потоков
	ExecutorService executorService = Executors.newFixedThreadPool( nThreads );
	// передача заданий, которые потоки будут делить между собой и выполнять
	executorService.🚩submit🚩(new Runnable() { /* ... */ }); // or instance of class implements Runnable
	executorService.🚩shutdown🚩(); // стоп передачи заданий и запуск выполнения
	executorService.🚩awaitTermination(🚩1, TimeUnit.DAYS); // ожидание окончания, останавливает основной поток до выполнения или достижения времени ожидания
⏸
Callable Future
Интерфейсы для получения 🚩значения🚩 из потока, т.к. run() в Runnable - 🚩void.
Для Callable необходимо определить тип 🚩возвр-го значения🚩 - аналогичный для метода 🚩call🚩:
	Future future = executorService.submit(new Callable<Integer>() {
		@Override
		public Integer 🚩call🚩() throws Exception{
			/* …  */
			return (new Random()).nextInt(10);
		}
	}); 
	// останавливает программу до выполнения потока!, возвращает значение
	future.🚩get🚩();
исключение (системное или кастомное) при выполнении 🚩get()🚩 попадает в 🚩ExecutionException
⏸
volatile
чтение и запись переменной всегда в 🚩основную память🚩, а не в 🚩кэши ядер🚩, что медленнее, но обеспечивает единое значение при чтении из разных потоков. Применима в случае если переменная пишется только из одного потока.
⏸
synchronized
предваряет 🚩блок кода🚩 или 🚩метод🚩, который подлежит синхронизации, т.е. выполнять данный код в одно время может только 🚩один поток🚩, остальные ждут разрешения…
Синхронизация происходит на 🚩объекте🚩, монитор доступа к нему 🚩блокируется🚩, т.е. все синхронизированные коды(методы/блоки) этого объекта доступны только одному потоку.

В методах синхронизация происходит на текущем объекте (this), 
в блоках - необходимо 🚩определить🚩 объект явно, что позволяет организовать одновременное выполнение разных(независимых) кодов(сущностей/процессов), исключив одновременное выполнение одного и того же кода.
⏸
wait - notify
wait() вызывается только в пределах 🚩синхронизованного блока🚩:
	🚩останавливает🚩 выполнение кода
	отдает 🚩монитор доступа🚩 другим потокам
	и 🚩ожидает🚩 вызов 🚩notify()🚩 на том же объекте
при вызове следует явно указывать 🚩объект вызова🚩, по умолчанию это текущий (this), но при синхронизации не на this, следует указать соотв. объект	
notify() - 🚩пробуждает🚩 ожидающий поток, но сам 🚩не освобождает🚩 монитор, монитор отдается по 🚩выполнению🚩 синхронизованного блока.

⏹
Потоковые классы
ArrayBlockingQueue
🚩очередь🚩 с 🚩фиксированной🚩 емкостью. Позволяет реализовать многопоточный паттерн 🚩Producer-Consumer🚩 (производитель-потребитель).
🚩put🚩() - при 🚩полной🚩 очереди ожидает 🚩освобождения🚩 места, чтобы добавить элемент.
🚩take🚩() - при 🚩пустой🚩 очереди ожидает 🚩добавления🚩 элемента, чтобы извлечь его.
⏸
CountDownLatch
потокобезопасный “замок обратного отсчета” - 🚩остановка🚩 выполнения до отсчета заданного значения 🚩count🚩, т.е. от count до 0.
	CountDownLatch countDownLatch = new CountDownLatch(3);
	countDownLatch.await();// остановка выполнения до открытия замка
	// “обратный отсчет” в потоках
	countDownLatch.countDown();
⏸
Lock, ReentrantLock
java.util.concurrent.locks, 
можно использовать вместо 🚩synchronized🚩, избавляет от 🚩вложенных🚩 блоков 🚩synchronized🚩, если требуется синхронизировать на 🚩разных🚩 объектах изменяемых одновременно, напр. два счета списание-начисление.
	Lock lock = new ReentrantLock();
	lock.lock(); // ставим блокировку, за пределами try
	try{
		/* some action... */
	}
	catch(SomeException e){
		//...
	}
	finally{
		lock.unlock(); // снимаем блокировку
	}
⏸
Deadlock
Lock позволяет решить мертвый лок (Deadlock) ситуация, когда разными потоками взаимно захвачены последовательно идущие локи в разном порядке и ждут друг друга до бесконечности…
метод 🚩tryLock()🚩 - захватывает лок, только если тот 🚩свободен🚩, без 🚩остановки🚩 для ожидания, возвращает true в случае 🚩успеха🚩, в случае false  - следует 🚩вернуть🚩 все локи для доступа одним из потоков.
⏸
Semaphore:
java.util.concurrent.locks, 
выдача 🚩разрешения🚩 на доступ.
	Semaphore semaphore = new Semaphore(3); //permits - количество разрешений
	semaphore.🚩acquire🚩(); // запросить допуск, если нет свободных - ждать…
	/* some action... */
	semaphore.🚩release🚩(); // вернуть допуск в finally!

	semaphore.🚩availablePermits🚩(); // свободных допусков
⏸
Phaser
Класс Phaser позволяет 🚩синхронизировать🚩 потоки, представляющие отдельную фазу или стадию выполнения общего действия.
Кол-во потоков-участников передается в конструктор, или метод 🚩register()🚩 регистрирует очередного участника.

int 🚩getPhase()🚩: возвращает номер текущей фазы
int 🚩arrive()🚩: сообщает, что сторона 🚩завершила🚩 фазу и возвращает номер текущей фазы
int 🚩arriveAndAwaitAdvance()🚩: аналогичен методу 🚩arrive🚩, только при этом заставляет phaser ожидать завершения фазы всеми остальными сторонами
int 🚩arriveAndDeregister()🚩: сообщает о завершении всех фаз стороной и снимает ее с 🚩регистрации🚩.

После вызова 🚩arriveAndAwaitAdvance🚩 выполнение потока останавливается, потока все участники не сообщат о завершении. Затем выполнение во всех участниках и т.д.
⏸
Exchanger
java.util.concurrent.Exchanger - 🚩обменник🚩 данными между потоками, через метод 🚩exchange()
	message=exchanger.exchange(message); // и чтение и запись в обменник

⏹
Преобразования типов
Бывает
	🚩Автоматическое
	🚩Явное
⏸
Автоматическое: типу с 🚩большей🚩 памятью можно присвоить тип с 🚩меньшей(или равной)
Явное:
	int a=0;
	long b=15;
	a = (int) b;

При преобразовании числа 🚩большего🚩, чем вмещает новый тип - невместимые 🚩левые🚩 разряды 🚩отсекаются🚩, т.е. происходит преобразование с потерей точности:
	int a = 258; // 00000000 00000000 00000001 00000010
	byte b = (byte) a;
	System.out.println(b);      // 2 т.к. 00000010
⏸
Общие особенности 
	При приведении 🚩float🚩 или 🚩double🚩 к целочисленным типам, дробная часть не округляется, а просто 🚩отбрасывается.
	При делении 🚩целочисленных🚩 чисел остаток 🚩отбрасывается🚩: 10/3 = 3 (т.е. приведение результата к целому), даже если результат присваивается переменной 🚩float🚩 или 🚩double🚩
	Тип 🚩boolean🚩 не приводится ни к одному из типов.
	Тип 🚩char🚩 приводится к числовым типам, как 🚩код символа🚩 в системе 🚩UNICODE.
⏸
Преобразования при операциях:
	если один из операндов 🚩double🚩, то и второй операнд преобразуется к типу 🚩double
	иначе, если один из операндов 🚩float🚩, то и второй преобразуется к типу 🚩float
	иначе, если один из операндов 🚩long🚩, то и второй операнд преобразуется к типу 🚩long
	иначе - все операнды преобразуются к типу 🚩int
итого: 🚩double float long int
⏸
Получение из строки:
🚩parse...
	byte x = Byte.parseByte("100");
	short x = Short.parseShort("100");
	int mInt = Integer.parseInt(mString);
	long x = Long.parseLong("100");
	float x = Float.parseFloat("19.95");
	double x = Double.parseDouble("19.95"); 
🚩valueOf
	Boolean boolean = Boolean.🚩valueOf🚩("true");
⏸
Приведение к строке:
Сложение со строкой (вариант плохой):
	int number = 1;
	String numberString = "" + number;

🚩String.valueOf🚩 (отличный вариант):
	String numberString = String.valueOf(number);
	также 
	String booleanString = String.valueOf(boolean);

🚩.toString🚩:
	Integer.toString(integer);
	Boolean.toString(boolean);

String.🚩format🚩 - хорошо для рациональных чисел float/double:
	double number = 0.000045158458;
	System.out.println(String.format("%.12f", number));

Character char = new Character('a');
	char.🚩charValue()🚩; // "a"

⏹
Tипы данных
Примитивные типы 8 штук:
5 🚩целочисленных🚩:
	🚩byte🚩(🚩байт🚩):  8 бит 256 значений (2 в степени 8) (-128…+127)
	🚩short🚩: 16 бит 65т. зн. (-32768…+32767)
	🚩int🚩: 32 бит 4млрд значений, все целочисленные литералы по умолчанию
	🚩long🚩: 64 бит млрд-ы млрд-ов..., нужно метить "🚩L🚩" если выходит за пределы int
		🚩long myLong = 789_123_456_789L; 
		(В Java 7 для целых чисел можно использовать знак 🚩подчёркивания🚩 для удобства)
	🚩char🚩 ch = 'f'; // символ, пишется в одинарных кавычках, 16 бит (0...65535)
		тоже считается целочисленным, т.к. может содержать код символа: 
		char ch = 102; //или 
		char ch = '\u0066'; // в 16-ной системе после \u
2 🚩вещественных🚩:
	🚩double🚩: 64 бит,  все литералы с плав.точкой по умолчанию
	🚩float🚩: 32 бит, необходимо метить "🚩f🚩" в конце, иначе по умолчанию создается 🚩double
		float myFloat = 456.123f;
1 🚩логический🚩:
	boolean boo = true;
⏸
Ссылочные типы: 
	🚩классы🚩, 🚩массивы🚩 и 🚩строки🚩:
		String str = "some string"; // объект класса String(java.lang), примитивного стринга не существует!
	обертки 🚩примитивных🚩 типов с 🚩большой🚩 буквы, напр. 🚩Short🚩 для short, 
	2 исключения: 🚩Integer🚩 и 🚩Character🚩

⏹
Структура памяти и GC
Два раздела памяти 🚩Stack🚩 и 🚩Heap🚩:
	🚩Stack🚩 - области выделенные при вызове 🚩методов🚩 и 🚩блоков кода🚩 (в фигурных скобках), в которых хранятся - 🚩примитивные типы🚩 и 🚩ссылки на объекты🚩(в Heap). Каждый 🚩поток🚩 имеет свой 🚩стек.
	🚩Heap🚩(куча) - хранит 🚩объекты🚩, ссылки на которые лежат в слоях Stack, String Pool.
		делится на 2 сегмента:
		🚩Young🚩(🚩New🚩) Generation хранятся молодые объекты в разделах:
			🚩Eden🚩 - новые (new)
			🚩Survivor🚩 - пережившие хотя бы одну 🚩сборку мусора GC🚩
		🚩Old🚩(🚩Tenured🚩) Generation - хранятся долгоживущие объекты(синглтоны, менеджеры ресурсов и проч)
	🚩Meta Space🚩 (до java 8 🚩Permanent🚩 Generation Space) - постоянное хранение метаданные классов, полей и методов, пул констант, ссылки на статические объекты, байт код и т.п.
	🚩MetaSpace🚩 в отличие от Perm может 🚩динамически расширяться🚩, Параметры 🚩PermSize и MaxPermSize🚩 упразднены, введен 🚩MaxMetaspaceSize🚩.
⏸
🚩GC Roots🚩 - корневые точки(корни древа) начиная с которых 🚩сборщик мусора🚩 проходит по 🚩бъектам🚩 и 🚩ссылкам🚩 между ними. Недостижимые объекты, потерявшие ссылки - считаются “мертвыми” и подлежат 🚩удалению🚩.

В GC Roots, т.е. гарантированно живые объекты, входят:
	Объекты в 🚩статических🚩 полях классов
	Объекты доступные со 🚩стэков
	Объекты из 🚩JNI🚩 ссылок в 🚩native🚩 методах
⏸
finalize
метод из Object, вызывается только 🚩непосредственно🚩 перед 🚩сборкой мусора🚩. Нет гарантии что будет 🚩вызван🚩, т.к. 🚩помещается в очередь🚩. Поэтому не стоит полагаться на finalize для 🚩чистки данных🚩 или 🚩освобождения ресурсов🚩. Рекомендовано использовать только для 🚩логирования ошибок🚩.

⏹
Stream и Сериализация
Потоки - абстракция для 🚩чтения или записи🚩 информации (файлов, сокетов, текста консоли и т.д.).
Объект, из которого можно считать данные, называется 🚩потоком ввода🚩, а объект, в который можно записывать данные - 🚩потоком вывода. 
Для чтения и записи: 
	байтов - семейство 🚩InputStream и OutputStream
	символов - семейство 🚩Reader и Writer.
Смесь этих двух функционалов: 
	🚩InputStreamReader🚩 и 🚩OutputStreamWriter🚩 - входной и выходной потоки, транслирующие байты в символы.
⏸
Классы 🚩Print🚩 - для форматируемого вывода:
🚩PrintStream🚩(напр. System.out) и 🚩PrintWriter🚩 - классы вывода и записи в переданный файл или поток вывода.
	методы:🚩println(), print(), printf()
⏸
Классы 🚩Buffered🚩 - обертка буфером для повышения производительности:
	🚩BufferedInputStream🚩 и 🚩BufferedOutputStream 
	🚩BufferedReader🚩 и 🚩BufferedWriter 
⏸
Нек. основные классы чтения и записи:
	🚩File🚩InputStream 🚩File🚩OutputStream байтов(не символов!) в 🚩файл
	🚩ByteArray🚩InputStream 🚩ByteArray🚩OutputStream из/в 🚩массив байтов
	🚩Data🚩InputStream 🚩Data🚩OutputStream 🚩примитивных типов🚩 и 🚩строк🚩(readUTF/writeUTF), например в файл
	🚩Object🚩InputStream 🚩Object🚩OutputStream сериализованных данных из/в поток. В конструкторе принимает ссылку на поток ввода/вывода.
	🚩Zip🚩InputStream 🚩Zip🚩OutputStream 🚩ZIP🚩-архивов, работают с объектом записи 🚩ZipEntry

	🚩File🚩Reader 🚩File🚩Writer символов в файл
	🚩String🚩Reader 🚩String🚩Writer символов в строку
⏸
Начиная с Java 7 введена конструкция 🚩try-with-resources🚩, которая автоматически вызывает метод 🚩close🚩. Работает с объектами, которые реализуют интерфейс 🚩AutoCloseable🚩. Все классы потоков реализуют интерфейс 🚩Closeable🚩, который в свою очередь наследуется от 🚩AutoCloseable🚩.
⏸
import java.io.*;
public class Program {
    public static void main(String[] args) {
        try(FileInputStream fin=new FileInputStream("C://SomeDir//notes.txt")){ // try-with-resources
            int i=-1;
            while((i=fin.read())!=-1){
                System.out.print((char)i);
            }   
        }
        catch(IOException ex){
            System.out.println(ex.getMessage());
        } 
    } 
}
⏸
Сериализация
- процесс записи 🚩состояния🚩 объекта в 🚩поток.
Десериализация - процесс 🚩извлечения🚩 или 🚩восстановления🚩 из потока 🚩состояния🚩 объекта.
⏸
Интерфейс 🚩Serializable
Сериализовать можно только объекты, реализующие интерфейс 🚩Serializable🚩. Этот интерфейс не 🚩определяет никаких методов🚩, просто он служит 🚩указателем🚩, что объект, реализующий его, может быть 🚩сериализован🚩.
У каждого класса, реализующего Serializable, должно быть поле, содержащее 🚩уникальный идентификатор версии🚩 сериализованного класса:
	private static final long 🚩serialVersionUID🚩 = ...L;
Если не объявить, java 🚩генерит🚩 сама, но возможны ошибки при выполнении 🚩восстановления🚩 объекта.
⏸
Классы 🚩ObjectInputStream и ObjectOutputStream🚩 исп. для чтения/записи 🚩сериализованных🚩 данных, примитивных типов или целых объектов, из/в поток. В конструкторе принимает ссылку на 🚩поток ввода/вывода🚩.
	SomeObject obj = new SomeObject();
	String fileName = "ser_data.bin";
	File file = 🚩new File(fileName);
	FileOutputStream fo = 🚩new FileOutputStream(file);
	ObjectOutputStream so = 🚩new ObjectOutputStream(fo);
	so.🚩writeObject(obj);
	so.🚩flush();
	so.🚩close();
	
	FileInputStream fi = 🚩new FileInputStream(file);
	ObjectOutputStream si = 🚩new ObjectOutputStream(fi);
	SomeObject objNew = (SomeObject)si.🚩readObject();
	si.🚩close();
⏸
🚩transient🚩 модификатор свойства объекта исключает это свойство из 🚩сериализации🚩, напр.:
	private 🚩transient🚩 boolean married;
все потомки Serializable класса - тоже 🚩Serializable
если родитель не Serializable то при воостановлении будет затребован его 🚩конструктор по умолчанию
⏸
Два специальных приватных метода вне всяких интерфейсов, которые java вызовет при сериализации
	writeObject(ObjectOutputStream out)
	readObject(ObjectInputStream in)
эти методы вызываются после записи метаданных объекта и его родителей и данных родителей.
в этих методах требуется всегда первым делом вызывать стандартную обработку чтения/записи:
	out.defaultWriteObject()
	in.defaultReadObject()
	
эти же методы входят в интерфейс java.io Externalizable (разумеется, как публичные)	
Интерфейс Externalizable позволяет определить сугубо кастомную сериализацию, т.е. ничего не будет сериализовано кроме того, что определено в методах: writeObject, readObject.

⏹
Stream API
Появился начиная с 🚩JDK 8🚩, работа с 🚩наборами данных🚩: фильтрации, сортировки и др.
Применительно к Stream API, "поток" представляет 🚩канал передачи🚩 данных из источника данных: файл, массив, коллекция.

import java.util.stream.*;
//.......................
long count = IntStream.of(-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5).filter(w -> w > 0).count();
System.out.println(count);

Все операции с потоками Stream API бывают 
	🚩терминальными🚩 (🚩terminal🚩)
	🚩промежуточными🚩 (🚩intermediate🚩)
⏸
Промежуточные операции возвращают 🚩трансформированный🚩 поток, например, методы 
	фильтрация и сортировка 🚩filter sorted
	объединение 🚩concat
	уникальность 🚩distinct
	ограничение 🚩limit
	пропуск 🚩skip
	маппинг на другой тип 🚩map
	итерация 🚩peek🚩(аналог 🚩forEach🚩 но не 🚩терминальная🚩). 
К возвращенному потоку можно продолжать 🚩применять🚩 операции.
⏸
Конечные или 🚩терминальные🚩 операции возвращают 🚩конкретный результат🚩, например, методы 
	количество 🚩count
	пределы 🚩min(Comparator) max(Comparator)
	итерация 🚩forEach
	найти 🚩findFirst findAny
	совпадение условию 🚩allMatch anyMatch noneMatch
	преобразование 🚩toArray
Продолжение работы с потоком 🚩невозможно.
⏸
Ряд операций сведения, такие как 
	пределы 🚩min max
	агрегатное вычисление 🚩reduce
	найти 🚩findFirst findAny
возвращают объект 🚩Optional<T>
	🚩get🚩 - получение значения, выбрасывает 🚩NoSuchElement🚩Exception если значения нет.
	🚩isPresent🚩 - возврашает true, если значение присутствует в Optional, 
	🚩ifPresent, ifPresentOrElse🚩  - "if"-группа, определют действия со значением в Optional, если значение имеется (или не имеется).
	🚩orElse, orElseGet, orElseThrow🚩 - "or"-группа, определют соответственно значение, действие и исключение если результата нет.
⏸	
Стримы бывают 🚩последовательными (sequential)🚩 и 🚩параллельными (parallel)🚩. 
	🚩последовательные🚩 выполняются только в 🚩текущем🚩 потоке
	🚩параллельные🚩 разбиваются на 🚩несколько групп🚩 и обрабатываются в 🚩каждом потоке отдельно.

Важно:
	Потоки 🚩не хранят🚩 элементы. Элементы, используемые в потоках, могут храниться в 🚩коллекции🚩, либо при необходимости могут быть напрямую 🚩сгенерированы🚩.
	Операции с потоками не 🚩изменяют🚩 источника данных. Операции с потоками лишь 🚩возвращают🚩 новый поток с 🚩результатами🚩 этих операций.
	Для потоков характерно 🚩отложенное🚩 выполнение. То есть 🚩выполнение🚩 всех операций с потоком происходит лишь тогда, когда выполняется 🚩терминальная операция🚩 и возвращается 🚩конкретный результат🚩, а не 🚩новый поток🚩.
⏸
Создание потока:
метод 🚩of(T..values)🚩 класса Stream:
	Stream<String> citiesStream =Stream.of("Париж", "Лондон", "Мадрид");
метод 🚩stream()🚩 интерфейса Collection,  и 🚩parallelStream()🚩
Files.🚩lines🚩 - каждая строка в файле будет отдельным элементом в стриме
«строка».🚩chars()🚩 - стрим из строки
Arrays.🚩stream(T[] array)🚩 - поток из массива:
⏸
	Stream<String> citiesStream = Arrays.stream(new String[]{"Париж", "Лондон", "Мадрид"}) ;
	IntStream intStream = Arrays.stream(new int[]{1,2,4,5,7});
	LongStream longStream = Arrays.stream(new long[]{100,250,400,5843787,237});
	DoubleStream doubleStream = Arrays.stream(new double[] {3.4, 6.7, 9.5, 8.2345, 121});
⏸	
Среди методов можно выделить
🚩reduce🚩  - терминальная операция для агрегатных вычислений, получает два аргумента — значение полученное на прошлых шагах и текущее значение.
	Arrays.asList(1, 2, 3, 4, 2).stream().reduce((s1, s2) -> s1 + s2).orElse(0);// 12
🚩collect🚩 - преобразовывает в коллекцию функцией-коллектором, есть готовые функции в 🚩Collectors🚩:
⏸
	List<String> filteredPhones = phones.stream() 
                .filter(s->s.length()<10)
                .collect(Collectors.🚩toList()🚩); //на выходе List
				// есть также 🚩toSet(), toMap()
				//.collect(Collectors.🚩toMap🚩(p->p.getName(), t->t.getPrice()));

⏹
Особенности Java 8
🚩Stream API🚩 - потоковые операции с наборами данных
⏸
объект 🚩Optional<T>🚩 - результат выполнения, которого 🚩может не быть.
⏸
🚩Лямбды🚩 -сокращенная форма создания объекта 🚩анонимного🚩 класса от 🚩функционального интерфейса🚩, путем описания реализации 🚩единственного🚩 метода. В Java 8 была добавлена специальная аннотация 🚩@FunctionalInterface🚩 для пометок от 🚩вмешательства🚩.
⏸
@FunctionalInterface
interface Operationable{ // функциональный интерфейс
    int calculate(int x, int y); // т.е. содержит единственный метод без реализации
}
-------------
// в одну строчку return писать не нужно
Operationable op = (x,y)->x+y; // эквивалентно ниже написанному...
Operationable op = new Operationable(){ // ...создание объекта анонимного класса
    public int calculate(int x, int y){
        return x + y;
    }
};
⏸
Встроенные 🚩функциональные🚩 интерфейсы
	🚩Predicate🚩 boolean 🚩test(T t)🚩 - 🚩проверка🚩 над объектом заданного типа
	🚩Supplier🚩 T 🚩get()🚩 - поставщик, 🚩возвращает🚩 объект заданного типа
	🚩Consumer🚩 void 🚩accept(T t)🚩 - потребитель, 🚩принимает🚩 объект заданного типа
	🚩Function🚩 R 🚩apply(T t)🚩 - 🚩переход🚩 от объекта типа T к объекту типа R
	🚩UnaryOperator🚩 T 🚩apply(T t)🚩 - действие с 🚩одним🚩 параметром
	🚩BinaryOperator🚩 T 🚩apply(T t1, T t2)🚩 - действие с 🚩двумя🚩 параметрами
⏸
Интерфейсы: методы 🚩по умолчанию🚩 и методы 🚩статические 
пример - методы Stream API: Collection.🚩stream()🚩, Stream.🚩forEach()🚩  и т.д.
⏸
Ссылочные методы, через знак "🚩::🚩"
	🚩Class::new🚩 – ссылка на 🚩конструктор
	🚩Class::static_method🚩 - ссылка на 🚩статический🚩 метод
	🚩Class::method🚩 - ссылка на 🚩нестатический🚩 метод 🚩любого🚩 объекта конкретного типа, для 🚩позднего🚩 связывания с конкретным объектом
	🚩instance::method🚩 - ссылка на 🚩нестатический🚩 метод 🚩конкретного🚩 объекта
⏸
Повторяющиеся аннотации, 🚩@Repeatable🚩 - для указания 🚩контейнера🚩 аннотаций
⏸
🚩java.time🚩  - новый пакет, классы для работы с датой, временем, час. поясами, продолжительностью и манипуляций со временем.
⏸
поддержка кодирования 🚩Base64🚩

⏹
Уровни изоляции транзакций

ACID - требования к транзакции
🚩Atomicity (атомарность)🚩 — единство 🚩фиксации🚩 или 🚩отката🚩 всех 🚩изменений.
🚩Consistency (согласованность)🚩 — 🚩согласованность данных🚩 (2+2=4) после фиксации или отката. 🚩Согласованность🚩 может нарушаться в ходе 🚩выполнения🚩, т.к. отдельные изменения не атомарны.
🚩Isolation (изолированность)🚩 — данные в промежуточном состоянии одной транзакции должны быть 🚩изолированы🚩 от других транзакций. Полная 🚩изоляция🚩 транзакции – очень дорогая операция, поэтому было принято разделение по 🚩степени изоляции🚩. 
🚩Durability (долговечность)🚩 — устойчивость, зафиксированные данные не должны быть 🚩отменены🚩 из-за какого-либо сбоя.
⏸
Побочные эффекты параллельного выполнения транзакций
🚩lost update🚩 - 🚩затирание🚩 одним потоком изменений другого
🚩dirty read🚩 - чтение 🚩незакоммиченных🚩 данных другой транзакции, промежуточных или затем откаченых(rollback)
🚩non-repeatable read🚩 - несоответствие при 🚩повторном🚩 чтении данных, 🚩измененных🚩 другой транзакцией
🚩phantom reads🚩 - несоответствие при 🚩повторном🚩 чтении данных, 🚩добавленных🚩 другой транзакцией
⏸
Уровни изоляции транзакций 
от низшего к высшему решают перечисленные побочные эффекты:
🚩read uncommited🚩 - изменение блокирует 🚩изменение🚩(параллельное).
🚩read commited🚩  - изменение блокирует 🚩чтение🚩(параллельное). Второй подход - 🚩версионность данных🚩: изменение работает с "🚩черновиком🚩" данных, недоступным остальным, которые видят только 🚩фиксированные🚩 данные
🚩repeatable read🚩 - 🚩чтение🚩 блокирует 🚩изменение🚩, но не 🚩добавление.
🚩serializable🚩 - 🚩чтение🚩 блокирует 🚩изменение и добавление🚩. Все транзакции полностью изолируются друг от друга, т.е. выполняются 🚩последовательно🚩.

⏹
Java collections framework
- это семейство 🚩классов🚩 и 🚩интерфейсов🚩, для 🚩хранения и манипуляций 🚩 набором данных.
⏸
Корневым интерфейсом является 🚩Collection🚩, который реализует интерфейс 🚩Iterable🚩, т.е. имеет методы 🚩Iterator<T> iterator(), forEach(Consumer action)
Основые методы:
	добавления: 🚩add(E e), addAll(Collection c)
	удаления: 🚩remove(Object o), clear(), removeAll(Collection c),retainAll(Collection c)
	анализа: 🚩size(), isEmpty(), contains(Object o)
	преобразования: 🚩toArray()

Collection напрямую наследуют интерфейсы: 
	🚩Queue
	🚩List
	🚩Set
⏸
Интерфейс очередь 🚩Queue
- это очередь с принципом 🚩FIFO (first-in-first-out)
Основые методы:
	добавить: 🚩add(), offer() (null вместо  exception)
	удалить первый(головной) элемент очереди: 🚩remove(), poll() (null вместо  exception)
	получить(украдкой) первый элемент, не удаляя из очереди: 🚩element(), peek (null вместо  exception)

Приоритетные очереди 🚩PriorityQueue🚩 и потокобезопасный 🚩PriorityBlockingQueue🚩 реализуют обработку по приоритетам, при этом объекты должны быть 🚩сортируемы🚩 либо  🚩естественным порядком🚩 либо через интерфейсы 🚩Comparator, Comparable🚩 (см. далее).
⏸
Интерфейс список 🚩List
Добавлены методы массива: 🚩get(), indexOf()

Основные реализации:
🚩ArrayList🚩 - массив с динамич. размером(классический имеет фикс.размер), внутри себя использует/пересоздает 🚩фикс.массив🚩. 
Особенности: 🚩быстрая вставка/удаление в конец, поиск по индексу.
🚩LinkedList🚩 - цепочка узлов с ссылками на след. и предыдущий. Реализует 🚩Queue.
Особенности: 🚩быстрая вставка в начало, удаление любого элемента, медленный поиск по индексу.

🚩Stack🚩 - потомок Vector(deprecated), принцип 🚩LIFO(last-in-first-out)
Основые методы:
	вставить 🚩push()
	забрать 🚩pop()
	получить 🚩peek()
	найти 🚩search()
	проверить на пустоту 🚩empty()
⏸
Интерфейс множество 🚩Set
набор 🚩уникальных🚩 элементов (множество), вставка дубликатов 🚩игнорируется.

Метод 🚩contains()🚩 - быстрая работа (в отличие от 🚩List🚩) благодаря 🚩хешированию
Работа с множествами с помощью методов 🚩Collection🚩:
сложение множеств 1 и 2: 🚩set1.addAll(set2)
выбрать(удержать) элементы из пересечения множеств 1 и 2: 🚩set1.retainAll(set2)
вычитание множества 2 из 1: 🚩set1.removeAll(set2) 

HashSet - 🚩неупорядоченная🚩 коллекция, в своей реализации использует 🚩HashMap🚩, т.е. хранит значения как 🚩ключи HashMap.
⏸
LinkedHashSet - 🚩упорядоченная🚩 коллекция, сохраняет 🚩порядок добавления.
⏸
TreeSet - 🚩упорядоченная🚩 коллекция, 🚩сортирует🚩 элементы, возможность сортировки определяется наличием 🚩естеств. порядка🚩(напр. для 🚩чисел или строк🚩) или реализацией интерфейса 🚩Comparable🚩 имеющего метод 🚩compareTo.

⏹
HashMap 
- 🚩неупорядоченная🚩 коллекция, 
реализован как 🚩массив связанных списков🚩, где индекс это 🚩пересчитанный хеш ключа🚩, а связ. список - 🚩цепочка узлов🚩, попавших в этот индекс по хешу ключа. 
Каждый узел содержит: 
	🚩хеш ключа, 
	🚩сам ключ, 
	🚩значение
	🚩связь со след. узлом(или null)
⏸	
LinkedHashMap - 🚩упорядоченная🚩 коллекция, сохраняет 🚩порядок добавления.
⏸
TreeMap - 🚩упорядоченная 🚩коллекция, 🚩сортирует🚩 пары по 🚩ключу🚩, про возможность сортировки - см. аналогично TreeSet.

⏹
Хеширование: 
преобразование массива данных 🚩произвольной длины🚩 в выходную 🚩битовую🚩 строку 🚩фиксированной длины.
⏸
hashcode() и equals()
Если хеш-коды разные, то и входные объекты гарантированно 🚩разные. 
Если хеш-коды равны - объекты 🚩не всегда равны🚩, т.к. множество возможных хеш-кодов ограничено 🚩примитивным типом int.
Совпадение кодов от разных объектов называют 🚩коллизией.
следовательно 
контракт hashcode equals: 
сперва - сравнение 🚩хеш-кодов🚩, в случае 🚩равенства🚩 - проверка на 🚩equals()🚩

equals() класса Object только сверяет входной объект с 🚩this
hashcode() класса Object реализован на 🚩другом языке🚩, в основе - 🚩генератор случайных чисел.

Если необходимо, чтобы разные объекты с одинаковым содержимым рассматривались как равные, то надо переопределить 🚩equals.
Переопределил equals — переопредели и 🚩hashCode🚩, т.к. 🚩hashCode🚩 - быстрая версия 🚩equals🚩, см контракт hashcode equals.

⏹
Comparator, Comparable, Iterable
Интерфейс Comparator
- "🚩сравнитель🚩", может быть передан вторым аргументом в статический метод 🚩Collections.sort() 
требует реализовать метод 🚩compare(Object1, Object2)
⏸
Интерфейс Comparable
 - "🚩способный к сравнению🚩", может быть добавлен в 🚩implements🚩 класса для реализации способности быть сравниваемым, например для сортировки.
требует реализовать метод 🚩compareTo(Object2)
⏸
Интерфейс Iterable
 - "🚩способный к перечислению, перечисляемый".
Метод 🚩iterator()🚩 - возвращает итератор, объект с логикой перечисления с методами 🚩next(), hasNext(), remove()
конструкция 🚩for(foreach)🚩  - обертка над итератором
но, итератором можно 🚩удалять🚩 текущий элемент, в отличие от 🚩удаления🚩 из 🚩коллекции🚩 в цикле, там возможно исключение 🚩ConcurrentModificationException
</textarea>

</div>
<div id="lessonOutput" style="float: left;"></div>
<div class="butPanel">
	<button id="buttonNextPhrase" onclick="trainingUtils.showRand()" class="but">►Rand...</button>
	<button id="buttonEngPhrase" onclick="trainingUtils.showThis()" class="but green">▼This...</button>
</div>

<div style="clear:both"></div>
<script type="text/javascript">
function infoWrapToggle(infoContentId){
	var i, elems = document.querySelectorAll('.infoContent');
	for(i=0;i<elems.length;i++){
		var infoContId = elems[i].id;
		document.getElementById(infoContId).style.display = infoContId===infoContentId ? 'block' : 'none'
	}

	document.getElementById('infoWrap').style.display = infoContentId ? 'block' : 'none';

}
function changeTheme(night){
	document.body.style.backgroundColor = night ? 'black' : 'white';
    document.body.style.color = night ? 'white' : 'black';
}
</script>
<div  id="infoWrap" style="">
	<div id="infoPanel">
        <input class="ipBut" title="Закрыть" type="button" value="&#215;" style="color: red;" onclick="infoWrapToggle();"/>
		<input class="ipBut" title="Настройки" type="button" value="☭" style="" onclick="infoWrapToggle('infoSetting')">
		<input class="ipBut" title="Помощь" type="button" value="&#9786;" style="" onclick="infoWrapToggle('infoHelp')">
        <!-- $('.ipBut').height(Math.floor(100/($('.ipBut').length+1))+'%')// автоподгон высоты -->
    </div>
	<div class="infoContent" id="infoHelp" style=""><h3>&#9786; Help</h3><hr/>
		<p>
			Веб-приложение "Разговорник - тренажер" для изучения/повторения английских фраз, адаптировано под мобильные устройства.
		</p>
		<!--p>
			Советы:
		</p>
		<ul>
			<li>Перед каждым новым уроком (набором карточек) - разминайтесь на предыдущем.</li>
			<li>Не "глотайте" больше одного набора карточек в день. Требует усвоения.</li>
			<li>Повторение - мать учения. Любите встроенный алгоритм повторений.</li>
			<li>И конечно, если понравилось - делитесь с друзьями: </li>
		</ul-->

		<script type="text/javascript" src="pluso.js"></script>
			<p>
				&#174; Денис Орлов <img style="height: 0.8em;" src="http://denisorlovmusic.ru/favicon.ico"> <a href="http://denisorlovmusic.ru/" title="Электронная музыка - Денис Орлов">HOME</a>
			</p>
	</div>
	<div class="infoContent" id="infoSetting" style=""><h3>☭ Settings</h3><hr/>
		<label><input type="checkbox" onclick="trainer.interchange = this.checked"/>
		Interchange native-foreign</label><br/>
		<label><input type="checkbox" onclick="trainer.showTransription = this.checked"/>
		Show transription (or show on click)</label><br/>
		<label><input type="checkbox" onclick="changeTheme(this.checked)"/>
		Night theme</label><br/>
		<label><input type="button" value="Mix!" onclick="trainer.utils.makeMix(33)">
		Make mixed lesson</label><br/>
	</div>
</div>
<script type="text/javascript">
var lesson_1 = document.getElementById('lesson_11'),
	lessonOutputDiv = document.getElementById('lessonOutput'),
	buttonPanel = document.getElementById('buttonPanel'),
	trainingCreator = new TrainingCreator(
		lesson_1,
		lessonOutputDiv,
		buttonPanel,
		'lessonPart',
		'question',
		function(){
			trainingCreator.outLesson(0);
		},
		{ // editKeysSymb
			stop: {key: 'ArrowUp', symbol: '⏹'},
			pause: {key: 'ArrowDown', symbol: '⏸'},
			question: {key: 'ArrowRight', symbol: '🚩'}
		}
		
	);
trainingCreator.outAllessons();
trainingCreator.buildButtonPanel();

function TrainingCreator(
	lessonTextArea,
	lessonOutputDiv,
	buttonPanel,
	lessonPartClassName,
	questionClassName,
	ctrlEnterFunction,
	editKeysSymb
){

	// private
	var _this = this;
	function insertAtCursor(myField, myValue) {
		//IE support
		if (document.selection) {
			myField.focus();
			sel = document.selection.createRange();
			sel.text = myValue;
		}
		//MOZILLA and others
		else if (myField.selectionStart || myField.selectionStart == '0') {
			var startPos = myField.selectionStart;
			var endPos = myField.selectionEnd;
			myField.value = myField.value.substring(0, startPos)
				+ myValue
				+ myField.value.substring(endPos, myField.value.length);
				
			myField.selectionStart = myField.selectionEnd = startPos+myValue.length;
		} else {
			myField.value += myValue;
		}
	}
	
	function keydownСtrlKeyHandler(event_key){
		var res = false;
		switch(event_key) {
		  case 'Enter':
			_this.ctrlEnterFunction();
			res = true;
			break;
		  default:
			break;
		}
		
		var k, obj;
		for(k in editKeysSymb){
			obj = editKeysSymb[k];
			if(obj.key == event_key){
				insertAtCursor(lessonTextArea, obj.symbol);
				res = true;
				break;
			}
		}
		
		return res;
	}
	
	lessonTextArea.addEventListener('keydown', function(event) {
	  event = event || window.event;
	  var target = event.target || event.srcElement;
	  if (event.ctrlKey && keydownСtrlKeyHandler(event.key)) {
		event.preventDefault();
		event.stopPropagation ? event.stopPropagation() : (event.cancelBubble=true);
	  }
	});
	
	function parseLessons(){
		return lessonTextArea.value.split(editKeysSymb.stop.symbol+'\n');
	}
	function clearLessonOutputDiv(){
		lessonOutputDiv.innerHTML = '';
	}
	function initParts(){
		var i, parts = lessonOutputDiv.querySelectorAll('.'+lessonPartClassName);
		for(i=0; i<parts.length;i++){
			let part = parts[i];
			if(part._trainingInit) continue;
			if(part.id.substr(-1) =='0' ) continue; // skip first
			
			part.style.opacity = 0.1;
			part.addEventListener('click', function(event) {
			  this.style.opacity = 1;
			})
		}
	}
	function initQuestions(){
		var i, qss = lessonOutputDiv.querySelectorAll('.'+questionClassName);
		for(i=0; i<qss.length;i++){
			let qs = qss[i];
			if(qs._trainingInit) continue;
			
			qs.style.fontFamily = 'monospace';
			qs.style.display = 'inline-block';
			var content = qs.innerHTML.trim(), 
				rect = qs.getBoundingClientRect(),
				_content = content.replace(/ (и|или) /g, ' '). // убираем и|или
					replace(/\([^\)]*\)/g, '') // убираем все в скобках
				,
				isZap = _content.indexOf(',')>-1,
				cnt = _content.split( isZap ? ',' : ' ').length
			;
			qs.style.minWidth = rect.width+'px';
			qs.style.textAlign = 'center';
			qs.style.borderBottom = '1px dashed black';
			
			qs._trainingInit = {
				content: qs.innerHTML,
				contentTip: qs.innerHTML.split("").reverse().join("").replace(/[\w\u0400-\u04FF](?=[\w\u0400-\u04FF])/g, 'ˍ').split("").reverse().join(""),
				alterContent: editKeysSymb.question.symbol+ (cnt == 1 ? '' : (cnt+' '+( isZap ? 'шт.' : 'сл.'))),
				setState(state){
					qs.innerHTML = qs._trainingInit[state];
					qs._trainingInit.state = state;
				}
			}
			qs._trainingInit.setState('alterContent');
			qs.addEventListener('click', function(event) {
			  switch(this._trainingInit.state) {
				  case 'alterContent':
					this._trainingInit.setState('contentTip');
					break;
				  case 'contentTip':
					this._trainingInit.setState('content');
					break;
				  case 'content':
					this._trainingInit.setState('alterContent');
					break;
				}
			})
		}
	} 
	function prepareQuestionStr(str){
		return '<b class="'+questionClassName+'">'+str+'</b>';
	}
	function prepareRow(row, pi, ri){
		//row = row.replace(/</g, '&lt;'); // break on reverse :(
		if(pi==0 && ri==0){
			row = '<h3>'+row+'</h3>';
		}else{
			var i, arr = row.split(editKeysSymb.question.symbol), str='';
			for(i=0; i<arr.length;i++){
				str+= i%2!=0 ? prepareQuestionStr(arr[i]) : arr[i];
			}
			row = str;
		}
		
		return row.length>0 ? row : ' ';
	}
	function buildLessonDiv(ind){
		var pi, lessonDiv, part, partDiv, rows, row, rowDiv, ri,
			currentLesson = _this.lessons[ind].split(editKeysSymb.pause.symbol);
		;
		lessonDiv = document.createElement('div'); 
		lessonDiv.id = 'lesson_'+ind;
		lessonDiv.className = 'lesson';
		for(pi=0; pi < currentLesson.length;pi++){
			part = currentLesson[pi];
			partDiv = document.createElement('div');
			partDiv.id = 'lessonPart_'+ind+'_'+pi;
			partDiv.className = lessonPartClassName;	
			
			rows = part.split('\n');
			for(ri=0; ri<rows.length; ri++){
				row = rows[ri],
				rowDiv = document.createElement('div');
				rowDiv.id = 'lessonRow_'+ind+'_'+pi+'_'+ri;	
				rowDiv.className = 'lessonRow';
				rowDiv.innerHTML = prepareRow(row, pi, ri);
				
				partDiv.appendChild(rowDiv);
			}
			
			lessonDiv.appendChild(partDiv);
		}
		
		return lessonDiv;
	}
	
	// public
	this.lessons = [];
	this.currentIndex = null;
	this.ctrlEnterFunction = ctrlEnterFunction;
	this.handleKey = function(event_key){
		keydownСtrlKeyHandler(event_key);
	}
	this.outAllessons = function(){
		this.lessons = parseLessons();
		if(this.lessons.length<1){
			return;
		}
		
		clearLessonOutputDiv();
		
		for(ind=0; ind<this.lessons.length; ind++){
			this.currentIndex = ind;
			lessonOutputDiv.appendChild(buildLessonDiv(ind));
		}
		
		initParts();
		initQuestions();
	}
	this.outLesson = function(ind){
		this.lessons = parseLessons();
		if(ind>this.lessons.length-1){
			alert('Out of index of lesson: '+lessons.length-1); return;
		}
		clearLessonOutputDiv();
		
		this.currentIndex = ind;
		lessonOutputDiv.appendChild(buildLessonDiv(ind));
		
		initParts();
		initQuestions();
	}
	
	this.buildButtonPanel = function(){
		let k, but;
		for(k in editKeysSymb){
			let ev = editKeysSymb[k];
			but = document.createElement('button');
			but.title = k+' (Ctrl+'+ev.key+')';
			but.className = 'editButton';
			but.innerHTML = ev.symbol+' '+k;
			but.onclick = function(event){
				_this.handleKey(ev.key); 
			}
			buttonPanel.appendChild(but);
		}
	}

};

var trainingUtils = {
	closeEditing: function(){
		lesson_1.style.display = 'none';
		lessonOutputDiv.style.width = '82%';
		var i, qss = buttonPanel.querySelectorAll('.'+'editButton');
		for(i=0; i<qss.length;i++){
			qss[i].setAttribute('disabled', 'disabled');
		}
	},
	openEditing: function(){
		lesson_1.style.display = 'block';
		lessonOutputDiv.style.width = '50%';
		var i, qss = buttonPanel.querySelectorAll('.'+'editButton');
		for(i=0; i<qss.length;i++){
			qss[i].removeAttribute('disabled');
		}
	},
	getRandomInt: (function randomInt(){
		var last, rand;
		return function(min, max, norepeat){
			if(max-min>1 && norepeat){
				do{
					rand = Math.round( min +Math.random()*(max-min)); //mylog([last, rand]);
				}while( rand == last )
				last = rand;
			}else{
				rand = Math.round( min +Math.random()*(max-min));
			}
			return  rand ;
		};
	}()),
	showRand: function(){
		trainingCreator.outLesson(this.getRandomInt(0, trainingCreator.lessons.length-1, true));
	},
	showThis: function(){
		trainingCreator.outLesson(trainingCreator.currentIndex);
	},
	initLessonCombo: function(lessonComboId){
		var select = document.getElementById(lessonComboId), i, alesson;

		select.appendChild( new Option('все', -1,  false, false) );
		for(i=0;i<trainingCreator.lessons.length;i++){
			alesson = trainingCreator.lessons[i].split('\n');
			select.appendChild( new Option(alesson[0], i,  false, false) );
		}

		select.onchange = function(e){
		  if(this.value==-1)
			trainingCreator.outAllessons();
			else
			trainingCreator.outLesson(this.value);
		};
	}
}
trainingUtils.closeEditing();
trainingUtils.initLessonCombo('lessonCombo');
</script>
</body>
</html>